From 47612396bab1c0c3ccd763f174709871a6308d95 Mon Sep 17 00:00:00 2001
From: Antoine Busque <antoinebusque@gmail.com>
Date: Wed, 2 Aug 2017 01:45:58 -0400
Subject: [PATCH 1/4] Fix: only set active frame when needed in sync_wins

Only set the active frame after destryoing a normal window in
`sync_wins` if this window was on the current screen. This mirrors the
behaviour already found in other functions like `unmap_notify`,
`destroy_notify`, etc.

Signed-off-by: Antoine Busque <antoinebusque@gmail.com>
---
 src/actions.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/actions.c b/src/actions.c
index 60e90e9..af93e27 100644
--- a/src/actions.c
+++ b/src/actions.c
@@ -5021,7 +5021,8 @@ sync_wins (void)
               if (frame)
                 {
                   cleanup_frame (frame);
-                  if (frame->number == win->scr->current_frame)
+                  if (frame->number == win->scr->current_frame
+                      && rp_current_screen == win->scr)
                     set_active_frame (frame, 0);
                 }
               withdraw_window (win);

From c16e757b838eb5a7fde1e7e4794a0e9865d8d5c7 Mon Sep 17 00:00:00 2001
From: Antoine Busque <antoinebusque@gmail.com>
Date: Thu, 21 Sep 2017 20:01:53 -0400
Subject: [PATCH 2/4] Fix: don't draw help window beyond screen height

The current computation for the drawing of the help window uses the
value `s->top + s->height` as the bottom edge of the screen, even
though the y values of the help strings being drawn are already
relative to the top of the screen. This results in some help strings
being drawn beyond the true edge of the screen, and therefore cut off.

Simply using `s->height` corrects this issue, and the help window gets
drawn properly even on multi-screen setups with differently sized
screens.

Signed-off-by: Antoine Busque <antoinebusque@gmail.com>
---
 src/actions.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/actions.c b/src/actions.c
index e65ca0c..d80cf88 100644
--- a/src/actions.c
+++ b/src/actions.c
@@ -3716,7 +3716,7 @@ cmd_help (int interactive, struct cmdarg **args)
 
           y += FONT_HEIGHT (s);
           /* Make sure the next line fits entirely within the window. */
-          if (y + FONT_HEIGHT (s) >= (s->top + s->height))
+          if (y + FONT_HEIGHT (s) >= s->height)
             {
               if (drawing_keys)
                 {

From 7416c20cdbe0b758d29e24ec5fa947673d7bb6d4 Mon Sep 17 00:00:00 2001
From: Antoine Busque <antoinebusque@gmail.com>
Date: Thu, 21 Sep 2017 20:16:06 -0400
Subject: [PATCH 3/4] Fix: draw the license text centered on multi-screen setup

The current implementation of the license command uses the `s->top`
and `s->left` values, combined with the screen's height and width to
compute the center of the screen to draw on. This is erroneous since
the x and y values of the text being drawn are already relative to the
current screen, causing the text to be rendered off-screen.

Simply removing the top and left values from the computation fixes
this issue and allows the license text to be drawn centered on the
current screen, even in multi-screen setups with differently sized
screens.

Signed-off-by: Antoine Busque <antoinebusque@gmail.com>
---
 src/actions.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/actions.c b/src/actions.c
index e65ca0c..9279b54 100644
--- a/src/actions.c
+++ b/src/actions.c
@@ -3598,8 +3598,8 @@ cmd_license (int interactive UNUSED, struct cmdarg **args UNUSED)
     }
 
   /* Offset the text so its in the center. */
-  x = s->left + (s->width - max_width) / 2;
-  y = s->top + (s->height - i * FONT_HEIGHT (s)) / 2;
+  x = (s->width - max_width) / 2;
+  y = (s->height - i * FONT_HEIGHT (s)) / 2;
   if (x < 0) x = 0;
   if (y < 0) y = 0;
 

From 68d8568d49dc1005d7c76248a1ec43fd59d02618 Mon Sep 17 00:00:00 2001
From: Antoine Busque <antoinebusque@gmail.com>
Date: Sun, 4 Feb 2018 22:08:30 -0500
Subject: [PATCH 4/4] Fix: exclude degenerate case from frame overlap

The current implementation of the find_frame_* functions considered
the degenerate case of frame overlap (i.e. a single pixel overlap, or
in other words, one frame beginning where the other ends) as valid.

This led to issues where certain frames would be impossible to reach
via focus* commands, since another frame with single pixel overlap
would be focused onto instead.

An easy way to reproduce such a case is to split one screen into 4
frames, by doing one vertical split and then two horizontal splits, or
vice versa. In the current implementation, the bottom-right frame is
unreachable via directional focus commands, since either the top-right
(when trying to focusright from the bottom-left) or bottom-left (when
trying to focusdown from the top-right) frames are focused onto, due
to a single pixel overlap.

Therefore, this patch excludes the degenerate case from being
considered as a valid frame overlap.

Signed-off-by: Antoine Busque <antoinebusque@gmail.com>
---
 src/split.c | 30 ++++++++++++++++++++++++++----
 1 file changed, 26 insertions(+), 4 deletions(-)

diff --git a/src/split.c b/src/split.c
index eed0f50..1c7d8b5 100644
--- a/src/split.c
+++ b/src/split.c
@@ -1000,6 +1000,28 @@ show_frame_message (char *msg)
   sbuf_free (msgbuf);
 }
 
+static int
+frames_overlap_horizontal (rp_frame *f1, rp_frame *f2)
+{
+  int f1_right = frame_right_abs (f1);
+  int f2_right = frame_right_abs (f2);
+  int f1_left = frame_left_abs (f1);
+  int f2_left = frame_left_abs (f2);
+
+  return f1_left < f2_right && f2_left < f1_right;
+}
+
+static int
+frames_overlap_vertical (rp_frame *f1, rp_frame *f2)
+{
+  int f1_bottom = frame_bottom_abs (f1);
+  int f2_bottom = frame_bottom_abs (f2);
+  int f1_top = frame_top_abs (f1);
+  int f2_top = frame_top_abs (f2);
+
+  return f1_top < f2_bottom && f2_top < f1_bottom;
+}
+
 rp_frame *
 find_frame_up (rp_frame *frame)
 {
@@ -1011,7 +1033,7 @@ find_frame_up (rp_frame *frame)
       list_for_each_entry (cur, &s->frames, node)
         {
           if (frame_top_abs (frame) == frame_bottom_abs (cur))
-            if (frame_right_abs (frame) >= frame_left_abs (cur) && frame_left_abs (frame) <= frame_right_abs (cur))
+            if (frames_overlap_horizontal (frame, cur))
               return cur;
         }
     }
@@ -1030,7 +1052,7 @@ find_frame_down (rp_frame *frame)
       list_for_each_entry (cur, &s->frames, node)
         {
           if (frame_bottom_abs (frame) == frame_top_abs (cur))
-            if (frame_right_abs (frame) >= frame_left_abs (cur) && frame_left_abs (frame) <= frame_right_abs (cur))
+            if (frames_overlap_horizontal (frame, cur))
               return cur;
         }
     }
@@ -1049,7 +1071,7 @@ find_frame_left (rp_frame *frame)
       list_for_each_entry (cur, &s->frames, node)
         {
           if (frame_left_abs (frame) == frame_right_abs (cur))
-            if (frame_bottom_abs (frame) >= frame_top_abs (cur) && frame_top_abs (frame) <= frame_bottom_abs (cur))
+            if (frames_overlap_vertical (frame, cur))
               return cur;
         }
     }
@@ -1068,7 +1090,7 @@ find_frame_right (rp_frame *frame)
       list_for_each_entry (cur, &s->frames, node)
         {
           if (frame_right_abs (frame) == frame_left_abs (cur))
-            if (frame_bottom_abs (frame) >= frame_top_abs (cur) && frame_top_abs (frame) <= frame_bottom_abs (cur))
+            if (frames_overlap_vertical (frame, cur))
               return cur;
         }
     }
